# **Навчальний посібник: Автоматизація веб\-інтерфейсів за допомогою Selenium WebDriver**

Тема: Розробка програмних роботів для веб\-браузерів.  
Практичний кейс: Автоматичне заповнення Google Форм на основі зовнішніх даних (CSV).

## **Зміст**

1. **Вступ. Еволюція веб\-автоматизації**  
   * 1.1. Що таке Selenium?  
   * 1.2. Компоненти екосистеми (IDE, Grid, WebDriver)  
   * 1.3. Selenium vs Playwright vs Cypress  
2. **Підготовка робочого середовища**  
   * 2.1. Встановлення Python та pip  
   * 2.2. Драйвери браузерів та WebDriver Manager  
   * 2.3. Віртуальні оточення (Best Practice)  
3. **Архітектура Selenium WebDriver**  
   * 3.1. Як працює протокол JSON Wire / W3C  
   * 3.2. Життєвий цикл сесії  
4. **Стратегії пошуку елементів (Locators)**  
   * 4.1. Структура DOM  
   * 4.2. Базові локатори (ID, Name, Class)  
   * 4.3. CSS Selectors: Швидкість та елегантність  
   * 4.4. XPath: Потужність навігації (і чому він необхідний для Google Forms)  
5. **Взаємодія з елементами**  
   * 5.1. Основні команди (Click, SendKeys, Clear)  
   * 5.2. Робота з випадаючими списками (Select vs Custom Divs)  
   * 5.3. ActionChains: Емуляція миші та клавіатури  
6. **Синхронізація та стабільність (Waits)**  
   * 6.1. Проблема Race Conditions  
   * 6.2. Implicit vs Explicit Waits  
   * 6.3. Fluent Wait  
7. **Просунуті можливості**  
   * 7.1. Виконання JavaScript (execute\_script)  
   * 7.2. Headless Mode (Робота без інтерфейсу)  
   * 7.3. Скріншоти та обробка вікон  
8. **Архітектурні патерни**  
   * 8.1. Page Object Model (POM)  
   * 8.2. Принципи DRY та KISS в автотестах  
9. **Практичний проект: Google Form Auto-filler**  
   * 9.1. Аналіз проблеми (Динамічні ID)  
   * 9.2. Алгоритм вирішення  
   * 9.3. Реалізація та розбір коду  
10. **Висновок та перспективи**

## **1\. Вступ. Еволюція веб\-автоматизації**

### **1.1. Що таке Selenium?**

Selenium — це не просто бібліотека, а набір інструментів з відкритим вихідним кодом для автоматизації дій у веб\-браузерах. Він дозволяє писати код, який імітує дії реальної людини: відкриває сторінки, натискає кнопки, заповнює форми та перевіряє результати.

Спочатку створений Джейсоном Хаггінсом у 2004 році як внутрішній інструмент компанії ThoughtWorks, Selenium став стандартом де\-факто в індустрії QA (Quality Assurance).

### **1.2. Компоненти екосистеми**

1. **Selenium IDE:** Розширення для браузера (Chrome, Firefox), яке працює за принципом "Record & Playback" (Запис і відтворення). Ідеально підходить для швидкого створення прототипів або баг\-репортів, але не підходить для складних, стабільних проектів.  
2. **Selenium Grid:** Інструмент для паралельного запуску тестів на різних машинах, операційних системах та версіях браузерів. Це основа для кросбраузерного тестування.  
3. **Selenium WebDriver:** (Основний фокус цього посібника). Це API, який дозволяє створювати надійні, об'єктно-орієнтовані скрипти для автоматизації. Він підтримує безліч мов програмування: Java, Python, C\#, Ruby, JavaScript.

### **1.3. Selenium vs Конкуренти**

Сучасний ринок автоматизації змінився.

* **Playwright (Microsoft):** Швидший, працює без драйверів, має вбудований auto-wait. Набирає популярність.  
* **Cypress:** Працює безпосередньо в браузері (JS), дуже швидкий, але обмежений лише одним вікном і мовою JS.  
* **Selenium:** Залишається лідером завдяки величезній спільноті, підтримці W3C стандарту та універсальності (можна автоматизувати будь-який браузер будь-якою мовою).

## **2\. Підготовка робочого середовища**

Для роботи з Selenium на Python необхідні три компоненти:

1. **Інтерпретатор Python.**  
2. **Бібліотека Selenium** (pip install selenium).  
3. **WebDriver** (виконуваний файл, що керує браузером).

### **2.2. Проблема драйверів**

Раніше розробникам доводилося вручну завантажувати chromedriver.exe, стежити за його версією (вона має співпадати з версією встановленого Chrome) та прописувати шлях у змінних середовища (PATH).

Сучасне рішення — бібліотека **webdriver-manager**. Вона автоматично перевіряє версію вашого браузера, завантажує потрібний драйвер і кешує його.

pip install webdriver-manager

\# Приклад ініціалізації  
from selenium import webdriver  
from selenium.webdriver.chrome.service import Service  
from webdriver\_manager.chrome import ChromeDriverManager

service \= Service(ChromeDriverManager().install())  
driver \= webdriver.Chrome(service=service)

## **3\. Архітектура Selenium WebDriver**

Розуміння того, як працює Selenium "під капотом", допомагає вирішувати складні помилки.

Архітектура базується на **Клієнт-Серверній моделі**:

1. **Selenium Client Library (Ваш код):** Ви пишете команду, наприклад element.click().  
2. **JSON Wire Protocol (HTTP):** Бібліотека перетворює цю команду на HTTP-запит (наприклад, POST /session/{id}/element/{id}/click).  
3. **Browser Driver (Сервер):** Це драйвер (chromedriver, geckodriver), який працює як легкий HTTP-сервер. Він отримує запит, розшифровує його.  
4. **Браузер:** Драйвер віддає команду браузеру через його нативні протоколи (наприклад, DevTools Protocol для Chrome).

Ця архітектура пояснює, чому Selenium повільніший за JS-фреймворки (є мережева затримка), але набагато стабільніший у імітації реальних дій користувача.

## **4\. Стратегії пошуку елементів (Locators)**

Це "серце" автоматизації. Якщо ви не можете знайти елемент, ви не можете з ним взаємодіяти.

### **4.1. DOM (Document Object Model)**

Веб-сторінка — це дерево об'єктів (тегів). Selenium шукає елементи в цьому дереві.

### **4.2. Базові локатори**

* **By.ID:** Найшвидший і найнадійніший. Але ID часто відсутні або генеруються динамічно.  
* **By.NAME:** Часто використовується у формах (\<input name="email"\>).  
* **By.CLASS\_NAME:** Ненадійний, якщо елемент має кілька класів (наприклад, btn btn-primary large).

### **4.3. XPath: Потужність навігації**

XPath (XML Path Language) дозволяє будувати складні запити до структури сторінки.

**Типи XPath:**

* **Абсолютний:** /html/body/div\[2\]/form/input. *Ніколи не використовуйте його\!* Будь-яка зміна дизайну зламає тест.  
* **Відносний:** //input\[@id='login'\]. Починається з //, шукає елемент де завгодно в документі.

**Ключові функції XPath для складних проектів (як Google Forms):**

1. **Пошук за текстом:** //span\[text()='Надіслати'\].  
2. **Частковий збіг:** //div\[contains(@class, 'question')\].  
3. **Осі (Axes):**  
   * parent::div (Батьківський елемент).  
   * following-sibling::input (Сусідній елемент знизу).  
   * ancestor::form (Предок будь-якого рівня вгору).

### **4.4. CSS Selectors**

Більш сучасний і швидкий спосіб, ніж XPath, але не вміє шукати за текстом (у стандарті CSS3).

* \#id  
* .class  
* div \> p (прямий нащадок)  
* input\[type='text'\] (за атрибутом)

## **5\. Взаємодія з елементами**

Після знаходження елемента (find\_element), об'єкт WebElement надає методи:

* .click() — Клік лівою кнопкою.  
* .send\_keys("text") — Введення тексту.  
* .send\_keys(Keys.ENTER) — Натискання спецклавіш.  
* .clear() — Очищення поля.  
* .get\_attribute("href") — Отримання посилання.  
* .text — Отримання видимого тексту.

### **5.2. Випадаючі списки (Dropdowns)**

Є два види списків:

1. **Стандартні (\<select\>):** Використовуйте клас selenium.webdriver.support.ui.Select.  
2. **Кастомні (на \<div\>):** Як у Google Forms. Тут Select не спрацює. Потрібно імітувати дії користувача:  
   * Клікнути на список (відкрити).  
   * Почекати появи опцій.  
   * Клікнути на потрібну опцію (часто за XPath з текстом).

## **6\. Синхронізація та стабільність (Waits)**

Найпоширеніша помилка новачків: **"Мій скрипт працює, але іноді падає з помилкою NoSuchElementException"**.

Причина: **Race Condition (Стан гонитви)**. Скрипт працює швидше, ніж браузер завантажує сторінку. Скрипт намагається клікнути на кнопку, якої ще немає в DOM.

### **6.1. Bad Practice: time.sleep()**

Жорстка пауза. Якщо поставити sleep(5), а сторінка завантажилась за 0.5с — ми втратили 4.5с. Якщо за 6с — скрипт впаде.

### **6.2. Implicit Wait (Неявне очікування)**

driver.implicitly\_wait(10)

Встановлюється один раз. Каже драйверу: "Якщо не знайшов елемент, спробуй ще раз протягом 10 секунд, перш ніж викинути помилку".  
Мінус: Працює лише для пошуку (find\_element), не чекає, поки кнопка стане клікабельною.

### **6.3. Explicit Wait (Явне очікування) — Best Practice**

Ми визначаємо конкретну умову (ExpectedCondition) і максимальний час очікування.

from selenium.webdriver.support.ui import WebDriverWait  
from selenium.webdriver.support import expected\_conditions as EC

\# Чекаємо до 10 сек, поки кнопка стане клікабельною  
button \= WebDriverWait(driver, 10).until(  
    EC.element\_to\_be\_clickable((By.ID, "submit"))  
)  
button.click()

Це робить тести швидкими (продовжує одразу, як умова виконана) і надійними.

## **7\. Просунуті можливості**

### **7.1. Виконання JavaScript**

Selenium не всесильний. Іноді елемент перекритий іншим прозорим блоком, і .click() видає помилку. JS дозволяє обійти перевірки видимості.

driver.execute\_script("arguments\[0\].click();", element)  
driver.execute\_script("window.scrollTo(0, document.body.scrollHeight);")

### **7.2. ActionChains**

Клас для складних жестів:

* Drag and Drop.  
* Наведення миші (Hover).  
* Клік з утриманням (Click and Hold).

### **7.3. Headless Mode**

Для запуску на серверах (CI/CD) або для прискорення скрапінгу можна запускати браузер без графічного інтерфейсу.

options \= webdriver.ChromeOptions()  
options.add\_argument("--headless")  
driver \= webdriver.Chrome(options=options)

## **8\. Архітектурні патерни: Page Object Model (POM)**

При зростанні проекту код стає "спагетті" — сумішшю локаторів, логіки і даних.  
Page Object Model — це патерн, де кожна сторінка веб\-сайту представлена як окремий клас у коді.

* **Локатори** зберігаються як змінні класу.  
* **Дії** (логін, пошук) реалізовані як методи класу.  
* **Тест** просто викликає методи, не знаючи про внутрішню реалізацію (XPath, CSS).

Це дозволяє легко підтримувати код: якщо змінився ID кнопки "Login", ми змінюємо його лише в одному місці (у класі LoginPage), а не у 50 тестах.

## **9\. Практичний проект: Google Form Auto-filler**

### **9.1. Постановка задачі**

Необхідно автоматизувати процес перенесення даних з Excel/CSV таблиці у Google Форму.  
Це актуально для HR (реєстрація кандидатів), вчителів (перенесення оцінок), маркетологів.

### **9.2. Технічні виклики Google Forms**

Google Forms — це складний SPA (Single Page Application).

1. **Динамічні ID:** Google генерує ID типу i25, entry.12345, які можуть змінюватися. Покладатись на них не можна.  
2. **Вкладеність:** Текст питання часто розбитий на кілька тегів \<span\>, що ускладнює пошук за точним текстом.  
3. **Різні типи input:** Текстові поля — це input, а радіо-кнопки — це спеціально стилізовані div, що вимагає різного підходу до кліків.

### **9.3. Рішення: "Розумний" пошук за ключовими словами**

**Логіка скрипта:**

1. **Читання даних:** Використовуємо csv.DictReader для отримання даних у форматі "Ключ-Значення".  
2. **Пошук контейнера:** Замість пошуку конкретного input, ми спочатку шукаємо весь блок питання (div role='listitem').  
3. **Глибокий текстовий аналіз:** Використовуємо XPath contains(., 'keyword'). Крапка . змушує XPath шукати текст у всіх вкладених елементах контейнера. Це вирішує проблему розбиття тексту на теги.  
4. **Евристика типу поля:**  
   * Знайшли контейнер \-\> Шукаємо всередині input\[type='text'\]. Знайшли? Заповнюємо.  
   * Немає тексту? \-\> Шукаємо елементи з роллю radio або checkbox. Знайшли? Клікаємо.  
   * Це Dropdown? \-\> Шукаємо role='listbox', клікаємо, чекаємо анімацію, шукаємо опцію глобально в DOM.

### **9.4. Важливість Exception Handling**

У проекті використано конструкцію try...except на кожному етапі. Якщо скрипт не може заповнити одне поле, він не падає повністю, а пише помилку в консоль і переходить до наступного поля або наступної форми. Це критично для обробки великих масивів даних.

## **10\. Висновок**

Selenium WebDriver залишається найпотужнішим інструментом для завдань, де потрібна складна взаємодія з інтерфейсом, яку неможливо реалізувати простими HTTP-запитами.

Реалізований проект автозаповнення форм демонструє перехід від простого лінійного коду до інтелектуального алгоритму, здатного адаптуватися до структури HTML. Опанування XPath, Explicit Waits та архітектури сторінки є ключовими навичками для будь-якого фахівця з автоматизації.